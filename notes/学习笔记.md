练习：https://github.com/Dream-Life/front-end/tree/master/engineer

# 工程化
1. 工程化的作用
    - 可以解决使用es6，7，8的兼容问题
    - 可以使用less，sass，postcss预编译（本身在运行环境是不能执行的）
    - 模块化/组件化提高可维护性（本身在运行环境是不能直接支持）
    - 自动化（原本需要手动压缩代码和资源文件，手动上传代码到服务器）
    - 统一代码风格，git代码质量保证
    - 解决对后端代码的依赖问题
2. 工程化：提高效率，质量保证，降低成本
# 脚手架工具
1. Yeoman
    - 安装：yarn global add yo generator-node
    - 生成: 新建一个文件夹my-module，在这个文件夹下执行 yo node(node 就是 generator-node)
    - 使用yarn安装依赖包，执行命令yarn link, 就会出现my-module命令，检查my-module --help
    - 可以在Yeoman官网查找generator相关的插件

2. 自定义Generator
    - mkdir generator-sample
    - cd generator-sample
    - yarn init && yarn add yeoman-generator
    - mkdir generators/app && cd generators/app
    - touch index.js
    ```javascript
    // generators/app/index.js
    // Generator 核心入口
    // 需要导出一个继承自Yeoman Generator的类型
    // Yeoman Generator在工作中会自动调用我们在此类型中定义的一些生命周期
    // 在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，比如文件写入

    const Generator = require('yeoman-generator')

    module.exports = class extends Generator{
        // yeoman 在询问用户环节会自动调用此方法
        // 在此方法中可以调用父类发prompt()方法发出对用户的命令行询问
        prompting(){
            return this.prompt([
                {
                    type: 'input',
                    name: 'title',
                    message: 'Your project name',
                    default: this.appname // appname为项目上传目录名称
                }, {
                    type: 'input',
                    name: 'success',
                    message: 'Your project name',
                    default: true // appname为项目上传目录名称
                }
            ]).then(answers=>{
                this.answers = answers
            })
        }
        writing(){
            // Yeoman 自动在生成文件阶段调用此方法
            // 我们在这里往项目目录中写入文件
            // this.fs.write(
            //     this.destinationPath('temp.txt'),
            //     Math.random().toString()
            // )

            // 通过模板方式写入文件到项目目录
            // 在app目录下新建templates目录，用于存放模板文件
            // 模板文件路径
            const tmpl = this.templatePath('foo.txt')
            // 输出路径
            const output = this.destinationPath('foo.txt')
            // 模板数据上下文
            const context = this.answers // {title: 'hello',success:true}

            this.fs.copyTpl(tmpl,output,context)
        }
    }
    ```
    - cd [generator-sample目录下] && yarn link
    - cd ../ && mkdir my-pro && cd my-pro
    - yo sample

3. 提交到npm
    - echo node_module > .gitignore
    - git init && git add . && git commit -m "msg"
    - git remote add origin [git http://....git 路径]
    - git push -u origin master
    - yarn publish [--registry-https://registry.yarnpkg.com] 或者 npm publish [--registry-https://registry.npmjs.org]
4. plop
    - 安装plop依赖
    - 在根目录下创建一个plopfile.js
    - 在plopfile.js定义脚手架任务
    - 编写用于生成特定类型文件的模板
    - 通过Plop提供的CLI运行脚手架任务
5. 脚手架工作原理
    - mkdir sample
    - cd sample
    - yarn init
    - yarn add inquirer ejs
    - 修改package.json,添加"bin": "cli.js",再在根目录下创建cli.js
    ```javascript
    #!/usr/bin/env node

    // node CLI 应用入口文件必须要有这样的文件头
    // 如果是linux和macOS系统下还需要修改此文件的读写权限 755
    // 可以通过chmod 755 cli.js来实现

    // 脚手架工作工程：
    // 1. 通过命令行交互询问用户问题
    // 2.根据用户回答的结果生成文件

    // console.log('working!')
    const inquirer = require("inquirer")
    const path =require('path')
    const fs = require('fs')
    const ejs = require('ejs')

    inquirer.prompt([
        {
            type: 'input',
            name: 'name',
            message: 'Your project name?'
        }
    ]).then(answers=>{
        // console.log(answers)

        // 模板目录
        const tmpDir = path.join(__dirname, 'templates')
        // 目标目录
        const destDir = process.cwd()

        // 将模板下的文件全部转换到目标目录
        fs.readdir(tmpDir, (err,files)=>{
            if(err) throw err
            files.forEach(file=>{
                // console.log(file)
                // 通过模板引擎渲染文件

                ejs.renderFile(path.join(tmpDir,file),answers,(err,res)=>{
                    if (err) throw err
                    // console.log(res)

                    fs.writeFileSync(path.join(destDir,file),res)
                })
            })
        })
    })
    ```
    - yarn link
    - sample (执行cli.js的任务)


# 自动化构建
1. 